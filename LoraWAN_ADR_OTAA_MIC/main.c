#include <lorawan/Lorawan.h>
#include <msp430.h>
#include "spi/spi.h"
#include <stdio.h>
#include "RestoreState/RestoreState.h"


#define MODE 1 // 0 receiver 1 transmitter

volatile int counter;

// The Network Session Key / DO NOT SHARE
// 20 FF 08 95 A0 D3 A1 14 86 15 18 53 C8 6E 34 66
//uint8_t NWKSKEY[16] = {0x20,0xFF,0x08,0x95,0xA0,0x4F,0xD3,0xA1,0x14,0x86,0x15,0x18,0x53,0xC8,0x34,0x66};
//uint8_t NWKSKEY[16] = {0x75, 0x21, 0xBB, 0x5F, 0x43, 0x79, 0x11, 0xB5, 0x0E, 0xEC, 0x04, 0xED, 0x0F, 0x0A, 0x7A, 0xBE};
//uint8_t NWKSKEY[16] = {0x41, 0x99, 0x31, 0x38, 0xF6, 0x07, 0x09, 0x33, 0x33, 0xF1, 0xDD, 0x91, 0x43, 0xE3, 0x98, 0xE8}; //FirABP1
//uint8_t NWKSKEY[NWKSKEY_SIZE] = {0xC8, 0xBB, 0xBA, 0xDB, 0x57, 0xD6, 0xCC, 0xB3, 0xB3, 0x5D, 0x5C, 0x83, 0xEE, 0xF6, 0xF6, 0xCC}; //FirABP2

// LoRaWAN AppSKey, application session key / DO NOT SHARE
// 45 C3 CE D2 E8 E9 B0 6D FA 80 5F A9 0C 43 9A 51
//uint8_t  APPSKEY[16] =  {0x45,0xC3,0xCE,0xD2,0xE8,0xE9,0xB0,0x6D,0xFA,0x80,0x5F,0xA9,0x0C,0x43,0x9A,0x51};
//uint8_t  APPSKEY[16] =  {0x59, 0xC1, 0x55, 0x8D, 0x4B, 0x49, 0xFB, 0xDC, 0xC4, 0x26, 0xFA, 0xE6, 0x17, 0x79, 0x9D, 0x38}; //FirABP1
//uint8_t  APPSKEY[APPSKEY_SIZE] =  {0xD7, 0x7B, 0x74, 0x9E, 0x0B, 0x68, 0xC3, 0xCA, 0x2C, 0x4C, 0x76, 0x8D, 0xF7, 0x0A, 0x26, 0xE5}; //FirABP2

// LoRaWAN end-device address (DevAddr) / DO NOT SHARE
//static const uint32_t DEVADDR = 0x26011D67 ;
//static const uint32_t DEVADDR = 0x260BF516;
//static const uint32_t DEVADDR = 0x260BCA89; //FirABP1
//static const uint32_t DEVADDR = 0x260BCFBC; //FirABP2 : DevEUI = 70 B3 D5 7E D0 05 E6 8A

//uint8_t DevEUI[8] = {0x70, 0xB3, 0xD5, 0x7E, 0xD0, 0x05, 0xFD, 0x18};   // Faraz - DevEUI, used to uniquely identify device globally, generated by TTN

uint8_t DevEUI[8] = {0x18, 0xFD, 0x05, 0xD0, 0x7E, 0xD5, 0xB3, 0x70};   // Faraz - DevEUI, used to uniquely identify device globally, generated by TTN


uint8_t APPKEY[16] = {0x4C, 0xA4, 0x41, 0xE7, 0x2D, 0x04, 0xE6, 0x7C, 0xEE, 0x3D, 0x31, 0xD1, 0x3D, 0x26, 0x8B, 0x91};  //Faraz - used for OTAA join encrypting/decrypting

uint8_t JoinEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; // Faraz - Join server, can be set as all zeros. Make sure same is set in TTN

#ifdef __TI_COMPILER_VERSION__
#pragma PERSISTENT(DevNonce)
uint16_t DevNonce = 0;          // Faraz - To keep track of number of join requests, requests with reused DevNonce will be rejected
#endif

#ifdef __TI_COMPILER_VERSION__
#pragma PERSISTENT(DEVADDR)
uint32_t DEVADDR = 0x00000000;          // Faraz - To save Device Address in persistent memory
#endif

#ifdef __TI_COMPILER_VERSION__
#pragma PERSISTENT(NWKSKEY)
uint8_t NWKSKEY[16] = {0};          // Faraz - To save Network Session key in persistent memory.
#endif

#ifdef __TI_COMPILER_VERSION__
#pragma PERSISTENT(APPSKEY)
uint8_t APPSKEY[16] = {0};          // Faraz - To save Application Session key in persistent memory.
#endif


#ifdef __TI_COMPILER_VERSION__
#pragma PERSISTENT(frameCounter)
uint32_t frameCounter = 0;      //Faraz - this will need to constantly be changed as frame counter needs to go up to match the server ideally this should be stored in fram
#endif

#ifdef __TI_COMPILER_VERSION__
#pragma PERSISTENT(FirstInitFlag)
uint8_t FirstInitFlag = 0;          // Faraz - A persistent flag variable to ensure the certain initialisations only occur on first run
#endif


/*
#pragma DATA_SECTION(instructions, ".reg_fram")
int instructions;                           //Faraz - To keep track of total no. of registers saved

#pragma DATA_SECTION(frameCounter, ".reg_fram")
uint32_t frameCounter;           //Faraz - To keep track of frame counter between power cycles
*/


#define NUM_DEVICE 10 //Number of test devices
#define NUM_FRAME_TEST 20 //Number of frames in a test cycle

typedef struct LoraDevice
{
    uint32_t devAddr;
    uint8_t nwk_s_key[16];
    uint8_t app_s_key[16];
}LoraDevice;

                                 //DevAddr   //NwkSKey                                                                                         //AppSKey
LoraDevice g_deviceArray[NUM_DEVICE] = {{0x260B48E2, {0x06, 0x2D, 0x9A, 0xE0, 0x11, 0x7E, 0x8E, 0x69, 0xFB, 0x49, 0x12, 0x8E, 0x64, 0x97, 0xCE, 0xE8}, {0x2A, 0x3C, 0x8A, 0x76, 0x37, 0x79, 0xA8, 0x60, 0xF6, 0xC0, 0x9D, 0x66, 0x57, 0x85, 0x89, 0x0E}},
                                        {0x260BF899, {0x6A, 0x3D, 0x1B, 0x46, 0xB7, 0x1E, 0xCC, 0x64, 0xDC, 0x7F, 0x77, 0x94, 0x95, 0xB9, 0xF9, 0x16}, {0xA7, 0x0C, 0x62, 0xFB, 0xCF, 0x38, 0x5C, 0xD8, 0xF5, 0xFE, 0xEE, 0x92, 0x3D, 0xD4, 0xC9, 0x67}},
                                        {0x260BB5F5, {0xDE, 0xDB, 0x31, 0x90, 0x5D, 0xF7, 0xB6, 0x07, 0xF5, 0x42, 0x9D, 0x8A, 0xB7, 0xC4, 0x93, 0x6F}, {0x46, 0x09, 0xF2, 0x20, 0x18, 0x37, 0x57, 0x0A, 0x20, 0x5B, 0xC0, 0xFE, 0xEC, 0x97, 0x7E, 0xAB}},
                                        {0x260B185E, {0x30, 0x5A, 0x11, 0x3C, 0x73, 0x6C, 0x2D, 0x2D, 0x03, 0x7D, 0xEF, 0x4A, 0xA0, 0x60, 0xB4, 0x3C}, {0xCB, 0x72, 0xCA, 0x68, 0xE7, 0x9D, 0x4E, 0x4C, 0xD4, 0x62, 0x6C, 0x16, 0x6E, 0x32, 0x33, 0x25}},
                                        {0x260BA886, {0x85, 0x52, 0x4A, 0xAD, 0x10, 0x3D, 0xD2, 0x9A, 0xB8, 0x33, 0xFC, 0xF9, 0x31, 0x60, 0xBD, 0x69}, {0x60, 0x44, 0x08, 0xC7, 0xA4, 0x0D, 0x85, 0x48, 0xF5, 0xA5, 0x54, 0x16, 0x6D, 0x4D, 0x20, 0xAA}},
                                        {0x260BDE51, {0x8C, 0x9E, 0x8C, 0xC5, 0x35, 0x35, 0x49, 0xEF, 0x9E, 0x66, 0x1D, 0x29, 0x97, 0x49, 0x69, 0x17}, {0xEE, 0xC5, 0x42, 0xB1, 0x95, 0x24, 0x9E, 0xFA, 0x43, 0x73, 0x7C, 0x1B, 0xCD, 0xE5, 0x40, 0xE9}},
                                        {0x260B4958, {0xA4, 0x01, 0xA1, 0xA9, 0x0B, 0x2E, 0x0A, 0x43, 0x8C, 0x90, 0x57, 0x7E, 0x21, 0x86, 0x8B, 0x5B}, {0x44, 0x35, 0x5D, 0xD5, 0xE4, 0xAD, 0x0E, 0x11, 0xCC, 0xAA, 0xBB, 0x6C, 0xE8, 0xF9, 0x6F, 0x2B}},
                                        {0x260B6677, {0x39, 0x0E, 0x9F, 0x9F, 0xAD, 0x46, 0xC1, 0xF5, 0xC3, 0xE2, 0x26, 0xFB, 0x47, 0xEA, 0xA0, 0xFC}, {0x26, 0xDF, 0x0B, 0x4F, 0x75, 0x07, 0xCF, 0xEA, 0x62, 0xDB, 0x1C, 0x54, 0xC2, 0x4E, 0xDE, 0x70}},
                                        {0x260B2CE6, {0x54, 0xD6, 0x23, 0xFC, 0xCA, 0x95, 0xC9, 0x4B, 0xC7, 0xC2, 0xC7, 0x44, 0x9D, 0x66, 0xC7, 0x9B}, {0xD5, 0x03, 0x21, 0xFC, 0xFE, 0xF0, 0x61, 0xB9, 0x20, 0x62, 0xBE, 0x3E, 0x6E, 0x0A, 0xBE, 0x20}},
                                        {0x260B5710, {0xD6, 0x1E, 0x0E, 0x1F, 0x41, 0x5A, 0x90, 0xD1, 0x47, 0x9F, 0x14, 0xFC, 0x95, 0xED, 0x07, 0x1C}, {0x32, 0x2F, 0xD9, 0xE5, 0xE3, 0x06, 0xDC, 0xD0, 0x98, 0xC6, 0x4E, 0xF5, 0x75, 0x92, 0xB6, 0x14}}};

int g_deviceArrayIndex = 0;
int g_test_done = 0;
//uint16_t DevNonce=0;//need to update this as requests get accepted (TTN allows 10 a day I think)

//88F59B8245AFC90EDA5ABED867DC502A
//uint8_t APPKEY[16] = {0x88, 0xF5, 0x9B, 0x82, 0x45, 0xAF, 0xC9, 0x0E, 0xDA, 0x5A, 0xBE, 0xD8, 0x67, 0xDC, 0x50, 0x2A};//used for OTAA joining

//flipped app key (least significant first)

//uint8_t APPKEY[16] = {0x2A, 0x50, 0xDC, 0x67, 0xD8, 0xBE, 0x5A, 0xDA, 0x0E, 0xC9, 0xAF, 0x45, 0x82, 0x9B, 0xF5, 0x88};//used for OTAA joining


//uint8_t JoinEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};//join server address (often complete zeros of generated through TTN it seems)

//70B3D57ED005A376
//uint8_t DevEUI[8] = {0x70, 0xB3, 0xD5, 0x7E, 0xD0, 0x05, 0xA3, 0x76};//device EUI
//address seems to appear backwards, need to flip
//uint8_t DevEUI[8] = {0x76, 0xA3, 0x05, 0xD0, 0x7E, 0xD5, 0xB3, 0x70};//device EUI


void Clock_configuration_8 (void){ // this function configures clock for 8MHz frequency
    CSCTL0_H = 0xA5;
    CSCTL1 &= ~(DCORSEL); //Set max. DCO setting. 8MH in this case
    CSCTL1 |= DCOFSEL0 + DCOFSEL1;
    CSCTL2 = SELA_1 + SELS_3 + SELM_3;
    CSCTL3 = DIVA_0 + DIVS_0 + DIVM_0;
    CSCTL0_H = 0x01; // Lock Register
}


void Clock_configuration_1 (void){
    CSCTL0_H = 0xA5;
    CSCTL1 &= ~(DCORSEL); //Set max. DCO setting. 1MH in this case
    CSCTL1 |= DCOFSEL0 + DCOFSEL1;
    CSCTL2 = SELA_1 + SELS_3 + SELM_3;
    CSCTL3 = DIVA__8 + DIVS__8 + DIVM__8;
    CSCTL0_H = 0x01; // Lock Register
}

void init_GPIO_pins(void)
{
    //SX1276 - DIO0 (P8.0)
    P8DIR &= ~BIT0;
    P8SEL1 &= ~BIT0;
    P8SEL0 &= ~BIT0;
    P8OUT &= ~BIT0; // Pull down
    P8IE &= ~BIT0;  // Interrupt disabled
    P8IFG &= ~BIT0; // Clear DIO0 interrupt
    P8IES &= ~BIT0; // Interrupt on a low to high transition

    // configure reset (P8.1)
    P8DIR |= BIT1;
    P8OUT |= BIT1; // Pull up
}

//setting some globals here as they are needed in the interrupt
int32_t numArr[]={43,56,29,11,71,90};
int numArrCounter=0;
int numArrSize=sizeof(numArr);
//int32_t demo_value=numArr[numArrCounter++];


int main(void)
{
    //printf("Hello \n");
    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer
    P1DIR |= BIT0;                  // configure P1.0 as output for LED stuff for debugging
    PM5CTL0 &= ~LOCKLPM5; // turn on I/O
    P1OUT |= BIT0;
    P1OUT ^= BIT0;              // toggle LED for debugging, should turn off
    P2DIR=0xFF;//initialise all pins as complains otherwise
    P2OUT=0;
    P3DIR=0xFF;
    P3OUT=0;
    P4DIR=0xFF;
    P4OUT=0;
    P5DIR=0xFF;
    P5OUT=0;
    P6DIR=0xFF;
    P6OUT=0;
    P7DIR=0xFF;
    P7OUT=0;
    P8DIR=0xFF;
    P8OUT=0;
    P9DIR=0xFF;
    P9OUT=0;
    PADIR=0xFF;
    PAOUT=0;
    PBDIR=0xFF;
    PBOUT=0;
    PCDIR=0xFF;
    PCOUT=0;
    PDDIR=0xFF;
    PDOUT=0;
    PEDIR=0xFF;
    PEOUT=0;


    srand(time(0));//seed random (needed for selecting OTAA join frequency)

    // Intitialize the MSP430 board
    Clock_configuration_1();
    init_GPIO_pins();
    Init_UART();
    init_spi();
    initLoraCtx();

    int i;

    LORA_CTX_t* loraCtx = Lorawan_getLoraCtx();     // From LoraWAN.h

    for(i=0;i<16;i++){
        loraCtx->appKey[i]=APPKEY[i];//Connor - adds appkey to struct for OTAA
    }

    if (FirstInitFlag == 0)         // Faraz - Check if this is the first run after flashing the code
    {
        lora_begins();              // Faraz - Initializing LoRa module registers with required values

        int Freqselect = 0;
        Freqselect=(rand()%3);      // Faraz - Selecting frequency for Join Request packet
        setJoinFreq(Freqselect);

        uint8_t JoinPacket[51]={0}; // Faraz - packet for join request, max size according to the things network

        uint8_t JoinPointer = buildOTAALoRaWANPacket(JoinPacket, JoinEUI, DevEUI, DevNonce, APPKEY);    // Faraz - Building the Join Req packet
        //DevNonce++;                 // Faraz - incrementing DevNonce so that it is different for next request if needed

        loraWANSend(JoinPacket, (JoinPointer)); // Faraz - Send the Join Req packet

        loraWANreceive();     // Faraz - Open receive window to get the DevAddr , NwkSKey & AppSKey

        DEVADDR = loraCtx->devAddr;

        printf("DevAddr = %08lx \n", DEVADDR);

        //printf("nwkSKey = ");
        for(i=0;i<16;i++)
            {
                NWKSKEY[i] = loraCtx->nwkSKey[i];   // Faraz - Save key from Global context to be saved in FRAM for future use
            }

        for(i=0;i<16;i++)
            {
                APPSKEY[i] = loraCtx->appSKey[i];   // Faraz - Save key from Global context to be saved in FRAM for future use
            }
        /*
        lora_change_SpreadingFactor(12);//Connor - to make sure being set to default for join request
        lora_set_signal_bandwidth(LORA_BW_125_KHZ);
        lora_setTxPower(MAX_EIRP);
        */

        FirstInitFlag = 1;          // Faraz - Set initialization flag to 1 so that it is never initialized again
    }

    else{                               //Need to load stored values back into loraCtx after power down
        loraCtx->devAddr = DEVADDR;
        for(i=0;i<16;i++)
            {
            loraCtx->nwkSKey[i] = NWKSKEY[i];
            }

        for(i=0;i<16;i++)
            {
            loraCtx->appSKey[i] = APPSKEY[i];
            }
    }

    Restore();                      // Faraz - Restore previous device state if any
    //printf(".text load start is %lx\n", _symval(&fram_rw_start));
    //printf(".text load end is %lx\n", _symval(&fram_rw_end));

    /*
    if(FirstInitFlag == 1){//connor - need to load stored values back into loraCtx after power down
            loraCtx->devAddr = DEVADDR;
            for(i=0;i<16;i++)
                {
                loraCtx->nwkSKey[i] = NWKSKEY[i];
                }

            for(i=0;i<16;i++)
                {
                loraCtx->appSKey[i] = APPSKEY[i];
                }
        }

     if  (FirstInitFlag == 0) {
         FirstInitFlag = 1;          // Faraz - Set initialization flag to 1 so that it is never initialized again
     }
     */

    //lora_begins1();
    //int32_t numArr[]={43,56,29,11,71,90};
    //int numArrCounter=0;
    //int numArrSize=sizeof(numArr);
    //int32_t demo_value=numArr[numArrCounter++];

    // Intialize TIMER
    TA0CCTL0 = CCIE;                        // TACCR0 interrupt enabled
    TA0CCR0 = 62500; // 0.5s
    TA0CTL = ID | TASSEL__SMCLK | MC__UP;        // SMCLK, UP mode
    // counter used inside the timer
    counter=0;

    //put the module in sleep mode
    lora_sleep();
    __bis_SR_register(LPM3_bits + GIE);     // Enter LPM0 w/ interrupt
    __no_operation();                       // For debugger

    while(1){};

    return 0;
}


#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)//triggered every half second
#pragma vector = TIMER0_A0_VECTOR
__interrupt void Timer0_A0_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(TIMER1_A0_VECTOR))) Timer0_A0_ISR (void)
#else
#error Compiler not supported!
#endif
{
    if(!g_test_done)
    {
        counter++;
        printf("counter = %d\n", counter);
        if(counter % 30 == 0)//this checks if x half seconds has passed (change this to change how often packets sent)
        {
            //int32_t demo_value = rand() % 1000000; // generate number between 0 and 1000000
            //int32_t numArr[]={43,56,29,11,71,90};
            //int numArrCounter=0;
            //int numArrSize=sizeof(numArr);
            //int32_t demo_value=numArr[numArrCounter++];
            P1OUT ^= BIT0;              // toggle LED for debugging, should turn on

            int i=0;
            //ideally do not want FRAM stuff here but seems like this needs to be here until  a better fix is found
            LORA_CTX_t* loraCtx = Lorawan_getLoraCtx();     // From LoraWAN.h

            DEVADDR = loraCtx->devAddr;

            printf("DevAddr = %08lx \n", DEVADDR);

                                  // Faraz - iterator for loop
            //printf("nwkSKey = ");
            for(i=0;i<16;i++)
                {
                    NWKSKEY[i] = loraCtx->nwkSKey[i];   // Faraz - Save key from Global context to be saved in FRAM for future use
                }

            for(i=0;i<16;i++)
                {
                    APPSKEY[i] = loraCtx->appSKey[i];   // Faraz - Save key from Global context to be saved in FRAM for future use
                }


            /*
            uint32_t demo_value=numArr[numArrCounter];
            if (numArrCounter<numArrSize){
                //demo_value=numArr[numArrCounter++];
                numArrCounter++;
            }else{
                numArrCounter=0;
            }
            if(numArrCounter>=6){//this bit just to make sure that counter is being reset properly
                numArrCounter=0;
            }*/
            uint32_t demo_value=0x0a0b0c0d;

            //randomly select one of the three join frequencies

            int select = 0;
            select=(rand()%3);
            setJoinFreq(select);

            /* this code does not work in the main due to a linking problem for some reason
            int select = 0;
            select=(rand()%3);
            //put in sleep mode
            lora_sleep();

            if (select==0){
                lora_setFrequency(868100000);//one of the official frequencies
            }if (select==1){
                lora_setFrequency(868300000);//one of the official frequencies
            }if (select==2){
                lora_setFrequency(868500000);//one of the official frequencies
            }

            // put in standby mode
            lora_idle();
            */

            //generate packet
            //uint8_t packet[20];
            //uint8_t packet[58];//need to set to max possible based off of minimum region specs, 59 is payload size not packet size but should do for now, this may be in bits not bytes though will have to check
            //could probably make this more advanced by changing it based off of data rate
            uint8_t packet[51]={0};//max size according to the things network

            //uint8_t packetPointer = buildOTAALoRaWANPacket(packet, JoinEUI, DevEUI, DevNonce, APPKEY);
            //DevNonce++;


            //128 bit encryption so need 16 bytes
            uint8_t payload[16]={0};

            //uint8_t header= 0x35; // can be anything as long as we stick with one number to indentify our devices

            payload[0] = (demo_value >> 24) & 0xFF;
            payload[1] = (demo_value >> 16) & 0xFF;
            payload[2] = (demo_value >>  8) & 0xFF;
            payload[3] = (demo_value >>  0) & 0xFF;

            //uint8_t result = packet_generator(packet,header,0x01,sizeof(payload),payload);

            //lora_send((uint8_t *)&packet, sizeof(packet));
            static const uint8_t FPort=0x01;//this needs to match the FPort value on the server

            //printf("frameCounter = %d\n", frameCounter);

            //uint8_t packetPointer = buildUnconfLoRaWANPacket(packet,g_deviceArray[g_deviceArrayIndex].devAddr,frameCounter,FPort,sizeof(payload),payload,g_deviceArray[g_deviceArrayIndex].nwk_s_key,g_deviceArray[g_deviceArrayIndex].app_s_key);//generates the packet and returns value
            //uint8_t packetPointer = buildUnconfLoRaWANPacket(packet,g_deviceArray[1].devAddr,frameCounter,FPort,sizeof(payload),payload,g_deviceArray[1].nwk_s_key,g_deviceArray[1].app_s_key);//generates the packet and returns value
            uint8_t packetPointer = buildUnconfLoRaWANPacket(packet,DEVADDR,frameCounter,FPort,sizeof(payload),payload,NWKSKEY,APPSKEY);//generates the packet and returns value


            //spreading factor stuff may not work depending on if transceiver is in sleep/stand by or not
            //uint8_t sFactor=9;//spreading factor of 9 to match gateway, turns out 9 is downlink, I think anything for uplink should work
            //lora_change_SpreadingFactor(sFactor);//this should hopefully set the spreading factor


            loraWANSend(packet, (packetPointer));//this should send the packet itself
            // change spreading factor (Apparently is not working correctly)
            //uint8_t sf = lora_get_SpreadingFactor();
            //uart_send_string(sf,sizeof(uint8_t));


            /*if(frameCounter == 20)
            {
                loraWANreceive();
            }*/
            //lora_change_SpreadingFactor(9);//Connor - need SF9 for Rx
            //loraWANreceive(g_deviceArray[0].nwk_s_key);
            loraWANreceive(NWKSKEY);

            g_deviceArrayIndex++;

            frameCounter++;
            /*
            if(frameCounter >= (frameCounter + NUM_FRAME_TEST))
            {
                //g_test_done = 1;
            }

            if(g_deviceArrayIndex >= NUM_DEVICE)
            {
                frameCounter++;
                g_deviceArrayIndex = 0;

                if(frameCounter > 10)
                {
                    g_test_done = 1;
                }
            }*/

            P1OUT ^= BIT0;              // toggle LED for debugging, should turn off
            counter=0;

        }
        lora_sleep();
    }
    else
    {
        printf("TEST DONE\n");
    }

}
